/////////////
// GLOBALS //
/////////////
cbuffer GradientBuffer
{
	float4 ApexColor;
	float4 CenterColor;

	//Time saved in FogColor.w
	float4 FogColor;
};



//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
	float4 Position : SV_POSITION;
	float2 DomePositionYAndWorldY : TEXCOORD0;
};

//This function is used for values in the 0 to 1 range; lerp values etc. 
//It's originally from Ken Perlin's perlin noise algorithm for smoothing transition between points.

//Essentially the ease curve will accentuate a value towards the extremes; 
//if it's a low value, it'll become lower, if it's a high value it'll become higher.
//If it's avg it won't move very much.
float PerlinEaseCurve(float value)
{
	//Algorithmically speaking: 3p² - 2p³
	return	(3.0f * (value*value) - (2.0f * (value*value*value)));
}


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 SkyspherePixelShader(PixelInputType input) : SV_TARGET0
{
	//Use time, saved in FogColor.w to lerp between these values.
	float4 sphereColor = lerp(ApexColor, CenterColor, FogColor.w);

	//Fog/Skysphere color lerp multiplier. It basically scales with the Y position of this pixel, plus a little offset to make the fog begin higher up.
	//We clamp it to 0-1 to make sure the lerp value doesn't get screwy.
	//After that we put it through a perlin ease curve to make the beginning and the end more extreme
	
	float fogMultiplier = 0.0f;

	
	if(input.DomePositionYAndWorldY.y < 200.0f)
	{
		fogMultiplier = PerlinEaseCurve(clamp(0.35f-input.DomePositionYAndWorldY.x, 0.0f, 1.0f));
		fogMultiplier *= (1.0f + 3.0f*(1.0f - (input.DomePositionYAndWorldY.y/200)));
		
		fogMultiplier = clamp(fogMultiplier, 0.0f, 1.0f);
	}

	return lerp(sphereColor, FogColor, fogMultiplier); //We want to scale so that furthest down on the skysphere is covered in fog
}