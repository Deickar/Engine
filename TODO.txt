
/********************************************************************************/
/*						TODO AND THINGS OF THAT SORT							*/
/********************************************************************************/

* Implement the settings library and populate it with everything relevant.

* Make some kind of cleanup function in terrainmanager that removes really far away chunks to keep memory down

* Decide upon a GUI library and implement it

* RTW shadowmapping < Cuz it's fuckin' awesome.

* Make geometry shader grass more fancy.
	-Should pretty much be finished now, just need to do the lookup-based-on-height thing.

* Water normal texture sliding thing that they do in arma2
* Skysphere texture mapping!!! Clouds? Stars?
* Shadow&Light manager...?
* Some sort of XML loader/reader for configs / keybindings / texture&material IDs


======== Idea regarding multithreading the terrain generation =============

You just have a function that is like AddFinishedChunkToMap(ChunkPointer val) with a ...mutex? in it.

So whenever one of the threads has created a chunk, it will lock the map, add its thing, then go to the next.

Can I call the same function with several threads? Or just use one separate thread dedicated to generation?

============================================================================

########## Idea regarding vegetation lookup table ##################

First you have a lookup texture, a 1DTextureArray that has the same amount of textures as you have height in the world. You index into this texture array with the grassquad's worldPos.Y
Each texture has the first pixel allocated to the amount of textures there are. So you read the first pixel value to know how many textures there are in this texture.
Then, when you know how many textures there are, you randomly select which texture you want to use. And then Load(1+(RandomVal*AmountOfTextures)). 
1+ because you don't want to use the first pixel in the texture.

Then you use the loaded texture ID to sample from your texture2DArray

###################################################################

¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤ How to identify separate islands and other parts to make separate meshes out of them ¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤
	
Simply walk through the entire voxel field, if something is inside==true, we create a vector to contain all of those vertices in a separate vector. 
Whenever we reach a vertice that isn't inside, it's clear that we have reached the end... 

Alternative would simply be to keep the voxel field after we've created the entire mesh. Every time a collision happens we re-create the mesh.

¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤¤

Rendering and general layout of rendering system:
http://gamedev.stackexchange.com/questions/22080/which-of-these-directx11-calls-actually-sends-data-to-the-gpu
http://www.dataorienteddesign.com/dodmain/node14.html
http://www.bitsquid.se/presentations/benefits-of-a-data-driven-renderer.pdf

Entity system:
http://www.gameprogblog.com/managing-entities/#more-79

Directional light lens flare:
http://www.madgamedev.com/post/2010/04/21/Article-Sun-and-Lens-Flare-as-a-Post-Process.aspx
http://stackoverflow.com/questions/14161727/hlsl-drawing-a-centered-circle
if dot(cameraDirection, lightDirection) == -1 then they're both facing opposite ways I think

Multithreading:
http://gamedev.stackexchange.com/questions/2116/multi-threaded-game-engine-design-resources
http://www.gamasutra.com/view/feature/1830/multithreaded_game_engine_.php
http://www.gamasutra.com/view/feature/2463/threading_3d_game_engine_basics.php
http://bitsquid.blogspot.se/2010/03/task-management-practical-example.html
*/

/*
http://stackoverflow.com/questions/86582/singleton-how-should-it-be-used
http://stackoverflow.com/questions/10892167/proper-implementation-of-global-configuration

 * C++ Singleton
 * Limitation: Single Threaded Design
 * See: http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf
 *      For problems associated with locking in multi threaded applications
 *
 * Limitation:
 * If you use this Singleton (A) within a destructor of another Singleton (B)
 * This Singleton (A) must be fully constructed before the constructor of (B)
 * is called.
 */
class MySingleton
{
	private:
		// Private Constructor
		MySingleton();
		// Stop the compiler generating methods of copy the object
		MySingleton(MySingleton const& copy);            // Not Implemented
		MySingleton& operator=(MySingleton const& copy); // Not Implemented

	public:
		static MySingleton& getInstance()
		{
			// The only instance
			// Guaranteed to be lazy initialized
			// Guaranteed that it will be destroyed correctly
			static MySingleton instance;
			return instance;
		}
};