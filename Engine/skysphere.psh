/////////////
// GLOBALS //
/////////////
cbuffer GradientBuffer
{
	float4 ApexColor;
	float4 CenterColor;
	float4 AntapexColor;
};

cbuffer TimeBuffer
{
	float time;
	float3 Padding;
};


//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
	float4 Position : SV_POSITION;
	float4 DomePosition : TEXCOORD0;
};

//Perlin noise ease curve: 3p² - 2p³
float PerlinEaseCurve(float value)
{
	return	(3.0f * (value*value) - (2.0f * (value*value*value)));
}


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 SkyspherePixelShader(PixelInputType input) : SV_TARGET0
{
	float width;
	float4 outputColor;

	// Determine the position on the sky dome where this pixel is located.
	width = (0.5f*input.DomePosition.x+0.5f)*time; //We translate it down from [-1,1] to [0,1], then we scale it with time. 

	if(width < 0.000001f) //Clamp values in one direction
	{
		outputColor = ApexColor;
	}
	else if(width > 1.0f || time >= 350.0f) //Clamp values in the other direction
	{
		outputColor = CenterColor;
	}
	else //Else we blend
	{
		outputColor = lerp(ApexColor, CenterColor, width);
	}

	return outputColor;
}