struct VertexShaderOutput
{
		float4 Position : SV_POSITION;
		float3 ViewRay : TEXCOORD0;
		float2 TexCoord : TEXCOORD2;
};

SamplerState sampler;
Texture2D shaderTextures[4] : register(ps_5_0, t1); //0 == depth, 1 == normal, 2 == random vectors, 3 == sampling kernel

//cbuffer PixelMatrixBufferType
//{
//	float4x4 View;
//	float4x4 InvertedProjection;
//	float4 FogColor;
//};

//cbuffer VariableBuffer
//{
//	int toggleSSAO		: packoffset(c0.x);
//	float sampleRadius	: packoffset(c0.y);	//Controls sampling radius. 0.1f to 1.0f are pretty ok values.
//	float intensity		: packoffset(c0.z); 	//AO intensity. The higher this value is, the darker the occluded parts will be. 1.0f to 10.0f values is pretty ok values.
//	float scale			: packoffset(c0.w);		//Scales distance between occluders and occludee. Still a little unsure as to what values would be good to use.
//	float bias			: packoffset(c1.x);			//Cutoff value. The higher this value is, the harsher we are with cutting off low AO values. 0.01f to 0.4f values are pretty ok.
//	float fogStart		: packoffset(c1.y);
//	float fogEnd		: packoffset(c1.z);
//	float farClip		: packoffset(c1.w);
//	float waterLevel	: packoffset(c2.x);
//	float cameraHeight	: packoffset(c2.y);
//	float2 randomSize	: packoffset(c2.z);
//	float2 screenSize	: packoffset(c3.x);
//	float2 PADDING		: packoffset(c3.z);
//};

//Decoding of GBuffer Normals
float3 DecodeNormal(float2 enc)
{
	float2 fenc = (enc*4.0f)-2.0f;
	float f = dot(fenc,fenc);
	float g = sqrt(1.0f-(f*0.25f));
	
	return float3(fenc*g, 1.0f - (f*0.5f));
}

float3 ReconstructViewPositionFromDepth(float3 viewRay, float depth)
{
	return viewRay * depth;
}

float4 ComposePixelShader(VertexShaderOutput input) : SV_Target0
{
		float depth = shaderTextures[2].Sample(samplers[0], input.TexCoord);
		float3 baseColor = shaderTextures[0].Sample(samplers[0], input.TexCoord).rgb;
		float fogFactor = saturate(((depth*farClip) - fogStart) / (fogEnd - fogStart));
		float4 fogColor = FogColor;
		float lightIntensity = 1.0f;

		if((cameraHeight-1) <= waterLevel)
		{
			//Scaling factor based on how far down into the water we are
			float waterDepth = clamp(1.0f - (0.04f * abs(waterLevel - cameraHeight)), 0.2f, 1.0f);

			//Light intensity diminishes the further down we go
			lightIntensity *= waterDepth;
			
			//Our vision range is shorter because underwater
			fogFactor = abs(1.0f - (waterDepth*0.7f));

			//Everything is darker because we're below the water
			baseColor.xyz -= (lightIntensity * float3(0.15f, 0.1f, 0.0f));

			//Make the fog a little darker too.
			fogColor.xyz -= (fogFactor * float3(0.3f, 0.3f, 0.0f));
		}
		else if(depth == 0.0f) //Skip as early as possible if this pixel isn't supposed to be lit. (Skysphere for example.)
		{
			return float4(baseColor, 1.0f);
		}

		if(fogFactor >= 1.0f)
		{
			return fogColor; //Cut early. Only return fog color.
		}

		float3 position = DepthToPosition(input.ScreenPosition, depth);//ReconstructViewPositionFromDepth(input.ViewPosition.xyz, depth);
		float3 normal = normalize(mul(DecodeNormal(shaderTextures[3].Sample(samplers[0], input.TexCoord).xy * 2.0f - 1.0f), (float3x3)View)); //Viewspace normals

		float ao = 1.0f;		
		
		if(toggleSSAO >= 1)
		{
			float2 rand = normalize(randomTexture.Sample(samplers[0], (screenSize*input.TexCoord / randomSize))  * 2.0f - 1.0f);
			float rad = sampleRadius / (0.01f+position.z);
			int iterations = lerp(4, 1, depth); //primitive SSAO LOD; scales with how close to the pixel we are

			//SSAO Calculation
			[unroll]
			for (int i = 0; i < iterations; i++)
			{
				float2 coord1 = reflect(vecArray[i], rand)*rad;
				float2 coord2 = float2(	coord1.x*0.707 - coord1.y*0.707,
										coord1.x*0.707 + coord1.y*0.707);
			
				ao += DoAmbientOcclusion(input.TexCoord, coord1*0.25,	input.ScreenPosition, position, normal);
				ao += DoAmbientOcclusion(input.TexCoord, coord2*0.5,	input.ScreenPosition, position, normal);
				ao += DoAmbientOcclusion(input.TexCoord, coord1*0.75,	input.ScreenPosition, position, normal);
				ao += DoAmbientOcclusion(input.TexCoord, coord2,		input.ScreenPosition, position, normal);
			}

			ao /= (float)(iterations*4.0f);

			//Add AO to final calculation ...
			ao = max((1.0f - ao), 0.0f); //max((1.0f - ao), 0.4f); //We don't want the ssao to make things completely black (0.0f), so we cap it at a minimum of 0.4f.
		}



		//specular intensity is stored in the color map's alpha channel.
		float4 light = shaderTextures[1].Sample(samplers[0], input.TexCoord) * lightIntensity;
		float3 diffuseLight = light.rgb;
		float specularLight = light.a;
		
		if(toggleSSAO == 2)
		{
			return float4(ao, ao, ao, 1.0f);//lerp((float4((ao * baseColor) * (diffuseLight + specularLight), 1.0f)),  FogColor, fogFactor); // float4(ao, ao, ao, 1.0f);//
		}
		else
		{
			//Default case
			return ao * lerp((float4((baseColor.xyz) * (diffuseLight + specularLight), 1.0f)),  fogColor, fogFactor);
		}
}