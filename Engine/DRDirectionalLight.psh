cbuffer PositionalBuffer //Whatever, idk what else to name it
{
	float3 LightDirection;
	float3 LightPosition;
	float3 CameraPosition;
	float3 Padding;
};
cbuffer PixelMatrixBuffer
{
	float4x4 InverseView;
	float4x4 InverseViewProjection;
	float4x4 LightViewProjection;
};

cbuffer LightBuffer
{
	float4 DiffuseColor;
	float4 AmbientColor;
	float Ka;
	//Ambient light coefficient
	float Kd;
	//Diffuse light coefficient
	float Ks;
	//Specular light coefficient
	float a;
	//Alpha coefficient
};

//0 == linear, 1 == point
//SamplerState samplers[2];

SamplerState linearSampler : register(s0);
SamplerComparisonState cmpSampler : register(s1);

// 0 = normal, 1 = standard depth, 2 = shadowmap depth.
Texture2D shaderTextures[3];


struct VertexShaderOutput
{
	float4 Position : SV_POSITION;
	float2 TexCoord : TEXCOORD0;
	float4 ViewPosition : TEXCOORD1;
	float4 ScreenPosition : TEXCOORD2;
	float4 WorldPosition : TEXCOORD3;
};

//Decoding of GBuffer Normals
float3 decode(float3 enc)
{
	return (2.0f * enc.xyz- 1.0f);
}

float2 texOffset( int u, int v )
{
	float2 shadowMapSize = float2(1024.0f, 1024.0f);
    return float2( u * 1.0f/shadowMapSize.x, v * 1.0f/shadowMapSize.y );
}

half4 LightPixelShader(VertexShaderOutput input) : SV_Target
{
	//compute ambient light
	half4 finalAmbienceProduct = half4(0.0f, 0.0f, 0.0f, 0.0f);
	half4 finalDiffuseProduct = half4(0.0f, 0.0f, 0.0f, 0.0f);
	float finalSpecularProduct = 0.0f;

	float depth = shaderTextures[1].Sample(linearSampler, input.TexCoord);
	
	if(0 >= depth) //Skip as early as possible if this pixel isn't supposed to be lit.
	{
		return finalAmbienceProduct; //0, 0, 0, 0
	}

	finalAmbienceProduct += Ka * AmbientColor;
	float4 encodedNormal = shaderTextures[0].Sample(linearSampler, input.TexCoord);
	float3 normal = normalize(decode(encodedNormal.xyz));

	input.ScreenPosition /= input.ScreenPosition.w; //Adjust value
	
	float4 position; //Reconstructing position
	position.xy = input.ScreenPosition.xy;
	position.z = depth; //Add camera depth
	position.w = 1.0f; //Set .w to 1.0f for later matrix multiplications


	position = mul(position, InverseViewProjection); //Extract pixel world position as seen from camera POV.
	position /= position.w; //Adjust value

	float4 lightScreenPos = mul(position, LightViewProjection); //Extract pixel position as seen from light POV for shadow map extraction.
	lightScreenPos /= lightScreenPos.w; //Adjust value again.

	float realDistanceToLight = lightScreenPos.z; //Depth as seen from light POV.

	float2 sampleLightScreen;
	sampleLightScreen.x = (lightScreenPos.x * 0.5f + 0.5f);
	sampleLightScreen.y = (-lightScreenPos.y * 0.5f + 0.5f);

	float shadowMultiplier = 1.0f;
	
	//We cull a large part of the light and shadow calculations if it's outside of the light frustum.
	if
	(		
		!(	sampleLightScreen.x > 1 || sampleLightScreen.x < 0	|| 
			sampleLightScreen.y > 1 || sampleLightScreen.y < 0	|| 
			lightScreenPos.z > 1	|| lightScreenPos.z < 0		)
	)
	{
		float sum = 0.0f;
		float x, y;

		//TODO: variance shadow mapping... http://http.developer.nvidia.com/GPUGems3/gpugems3_ch08.html

		realDistanceToLight -= 0.00002f; //Apply shadow bias

		//perform PCF filtering on a 4 x 4 texel neighborhood
		for (y = -1.5f; y <= 1.5f; y += 1.0f)
		{
			for (x = -1.5f; x <= 1.5f; x += 1.0f)
			{
				sum += shaderTextures[2].SampleCmpLevelZero(cmpSampler, sampleLightScreen + texOffset(x,y), realDistanceToLight);
			}
		}

		shadowMultiplier = (sum / 16.0f);

		////Use this instead for normal unfiltered shadows. Produces more artifacts. Nasty.

		//float distanceStoredInDepthMap = shaderTextures[2].Sample(linearSampler, sampleLightScreen);

		//if (realDistanceToLight < 1.0f && realDistanceToLight > distanceStoredInDepthMap)
		//{
		//	shadowMultiplier = 0.35f;
		//}
		
		//surface-to-light vector
		float3 lightVector = (-LightDirection);

		//Sigh, idk
		float NdL = (max(0, dot(normal, lightVector)));

		//reflection vector
		float3 reflectionVector = normalize(-reflect(lightVector, normal));

		//camera-to-surface vector
		float3 directionToCamera = normalize(position-CameraPosition);

		//compute diffuse light
		finalDiffuseProduct.xyzw += Kd * NdL;

		//compute specular light 
		finalSpecularProduct += Ks * pow( saturate(dot(directionToCamera, reflectionVector)), a);

	}

	//Storing specular in alpha channel. Applying shadow multiplier to both diffuse product and specular, but not ambient, to make sure it's not just black.
		return half4(finalAmbienceProduct.rgb + shadowMultiplier * (DiffuseColor.rgb*finalDiffuseProduct.rgb), shadowMultiplier * finalSpecularProduct);
}



/*


float4 ps_lighting(VS_OUTPUT IN) : SV_Target
{
	if (renderingSkel || renderingRBody)
	{
		return float4(1, 1, 1, 1);
	}
	else
	{
		//shadow mapping stuff
		IN.LightPosition.xyz /= IN.LightPosition.w;
		
		float4 ambient = ambientBright * materialAmbient;

		if( IN.LightPosition.x < -1.0f || IN.LightPosition.x > 1.0f || IN.LightPosition.y < -1.0f || IN.LightPosition.y > 1.0f || IN.LightPosition.z < 0.0f  || IN.LightPosition.z > 1.0f ) 
			return ambient;

		IN.LightPosition.x = IN.LightPosition.x/2 + 0.5;
		IN.LightPosition.y = IN.LightPosition.y/-2 + 0.5;

		float shadowMapDepth = shadowMap.Sample(ShadowSampler, IN.LightPosition.xy).r;

		if (shadowMapDepth < IN.LightPosition.z) return ambient;

		float3 V = normalize(IN.eye - IN.position);
		float3 R = reflect(lightDir, IN.normal);
		
		float4 diffuse = diffuseBright * (materialDiffuse * saturate(dot(lightDir, IN.normal)));
		float4 specular = specularBright * pow(saturate(dot(R, V)), normalize(shine));
		float4 finalColor = ambient + diffuse;
		if (shine > 0)
		{
			finalColor = saturate(finalColor + specular);
		}

		

		float4 color = texDiffuse.Sample(DiffuseSampler, IN.tex0);
		float4 sphCol = sphTexture.Sample(SphereSampler, IN.spTex);
		if (useTexture)
		{
			finalColor *= color;
		}
		if (useSphere)
		{
			if (isSphereAdd)
			{
				finalColor += sphCol;
			}
			else
			{
				finalColor *= sphCol;
			}
		}
		float4 o = (finalColor * extraBright) * fadeCoef;
		if (useTexture)
		{
			o.a = color.a * materialDiffuse.a;
		}
		else
		{
			o.a = materialDiffuse.a;
		}
		return o;
	}
}


*/