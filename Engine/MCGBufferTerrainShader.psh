struct VertexShaderOutput
{
	float4 Position : SV_POSITION;
	float4 WorldNormal : NORMAL;
	float4 WorldPosition : TEXCOORD0;
	float ViewDepth : TEXCOORD1;
};

struct PixelShaderOutput
{
	float4 Color : SV_TARGET0; //R8G8B8A8
	float4 Normal : SV_TARGET1; //R8G8B8A8
	float Depth : SV_TARGET2; //R32
};

cbuffer ColorTypeBuffer
{
	float4 toggleColorMode;
}

Texture2DArray shaderTextures;
Texture2D materialAndTextureLookupTable;
SamplerState textureSampler;

static const float3 UpNormal = float3(0.0f, 1.0f, 0.0f);
static const float tighten = 0.46f;
static const float textureScale = 0.1f;


//http://aras-p.info/texts/CompactNormalStorage.html#method04spheremap
//Normal Encoding Function
float2 Encode(float3 n)
{
	float p = sqrt(n.z*8.0f+8.0f);
	return float2(n.xy/p + 0.5f);
}

void ExtractMaterialAndTextureID(float4 encodedValues, out int texture1, out int texture2, out float material1, out float material2)
{
	texture1	=	round(encodedValues.x*255);
	texture2	=	round(encodedValues.y*255);
	material1	=	encodedValues.z;
	material2	=	encodedValues.w;
}

//When it gets read in other shaders it gets multiplied back to 255.
float EncodeMaterialID(float id)
{
	return (id / 255.0f);
}

//Trilinear projection blending
float3 CalculateBlendWeights(float3 NormalizedWorldNormal)
{
	float3 blend_weights = abs(NormalizedWorldNormal);     
	blend_weights = (blend_weights - 0.2f)*7.0f;  // Tighten up the blending zone
	blend_weights = max(blend_weights, 0.0001f);
	blend_weights /= (blend_weights.x + blend_weights.y + blend_weights.z).xxx; // Force weights to sum to 1.0 (very important!)

	return blend_weights;
}

PixelShaderOutput MCGBufferTerrainPixelShader(VertexShaderOutput input)
{
	PixelShaderOutput output = (PixelShaderOutput)0;
	int texture1, texture2;
	float material1, material2;

	//Create weights for color interpolation based on world-space normal of surface
	float3 NormalizedWorldNormal = normalize(input.WorldNormal.xyz);

	//... Long story short, it's a fix to counteract bugged normals in marching cubes terrain ...
	NormalizedWorldNormal.z += 0.01f;

	float3 blend_weights = CalculateBlendWeights(NormalizedWorldNormal);

	float4 YZColor = shaderTextures.Sample(textureSampler, float3(input.WorldPosition.yz * textureScale, 2.0f));
	float4 XYColor = shaderTextures.Sample(textureSampler, float3(input.WorldPosition.xy * textureScale, 2.0f));
	float4 XZColor; //Will be used further down

	//Index value for our lookup texture
	int extractionValue = round(input.WorldPosition.y-0.5f);

	//Send in the extraction value and get out two Texture IDs and two material IDs.
	ExtractMaterialAndTextureID(materialAndTextureLookupTable.Load(int3(extractionValue, 0, 0)), texture1, texture2, material1, material2);
	
	float dotResult = dot(UpNormal, NormalizedWorldNormal);

	//If surface is facing downwards, change textures but not materials
	if(dotResult <= 0.0f)
	{
		//Rock texture ID.
		texture1 = 2;
		texture2 = 2;
	}

	//Just used for debugging purposes right now.
	float3 finalTempColor = float3(255.0f, 0.0f, 0.0f);

	//If there are two different textures to lerp.
	if(texture1 != texture2)
	{
		finalTempColor.g += 255;

		//Create a lerp value. The range between two materials is always two coordinate units, hence the -2.0f and * 0.5f.
		output.Color.w = (input.WorldPosition.y - extractionValue);

		float3 firstCoords = float3(input.WorldPosition.zx * textureScale, texture1);
		float3 secondCoords = float3(input.WorldPosition.zx * textureScale, texture2);

		XZColor = lerp(shaderTextures.Sample(textureSampler, firstCoords), shaderTextures.Sample(textureSampler, secondCoords), output.Color.w);
	}
	else
	{
		XZColor = shaderTextures.Sample(textureSampler, float3(input.WorldPosition.zx * textureScale, texture1));
	}
	
	if((int)toggleColorMode.x == 0)
	{
		output.Color.xyz = finalTempColor.xyz;
	}
	else
	{
		output.Color.xyz = saturate((XZColor.xyz * blend_weights.yyy) + (YZColor.xyz * blend_weights.xxx) + (XYColor.xyz * blend_weights.zzz));
	}

	//Store an encoded normal in the XY channels. Only two channels! Amazing!
	//Encode material IDs and hide in normal Z and W channels
	output.Normal.xy = Encode(NormalizedWorldNormal); 
	output.Normal.z = material1;
	output.Normal.w = material2;

	//Store linear depth. Farclip is stored in toggleColorMode.y.
	output.Depth = (input.ViewDepth/toggleColorMode.y);

	return output;
}
