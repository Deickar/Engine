/////////////
// GLOBALS //
/////////////
cbuffer GradientBuffer
{
	float4 ApexColor;
	float4 CenterColor;
	float4 AntapexColor;
};

cbuffer TimeBuffer
{
	float time;
	float3 Padding;
};


//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
	float4 Position : SV_POSITION;
	float4 DomePosition : TEXCOORD0;
};

//Perlin noise ease curve: 3p² - 2p³
float PerlinEaseCurve(float value)
{
	return	(3.0f * (value*value) - (2.0f * (value*value*value)));
}


////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
float4 SkyspherePixelShader(PixelInputType input) : SV_TARGET0
{
	float4 fogColor = float4(0.6f, 0.6f, 0.6f, 1.0f);

	//Then it's night
	if(CenterColor.a < 0.9f)
	{
		fogColor = float4(0.05f, 0.05f, 0.05f, 1.0f);
	}

	float4 sphereColor = lerp(ApexColor, CenterColor, time);
	float fogMultiplier = PerlinEaseCurve(clamp(0.2f-input.DomePosition.y, 0.0f, 1.0f));
	//TODO: ... maybe just make an if()elseif()else() to better control the flow ..

	return lerp(sphereColor, fogColor, fogMultiplier); //We want to scale so that furthest down on the skysphere is covered in fog
}