struct VertexShaderOutput
{
	float4 Position : SV_POSITION;
	float3 WorldNormal : NORMAL;
	float4 WorldPosition : TEXCOORD0;
	float2 Depth : TEXCOORD1;
};

struct PixelShaderOutput
{
	float4 Color : SV_TARGET0; //R8G8B8A8
	float4 Normal : SV_TARGET1; //R8G8B8A8
	float Depth : SV_TARGET2; //R32
};

Texture2DArray shaderTextures;
SamplerState textureSampler;

//Normal Encoding Function
float3 Encode(float3 n)
{
	n = 0.5f * (n + 1.0f);

	return n;
}

//When it gets read in other shaders it gets multiplied back to 255.
float EncodeMaterialID(float id)
{
	return (id / 255.0f);
}

PixelShaderOutput MCubesGBufferPixelShader(VertexShaderOutput input)
{
	PixelShaderOutput output;

	float3 UpNormal = float3(0.0f, 1.0f, 0.0f);

	//Create weights for color interpolation based on world-space normal of surface
	float tighten = 0.5f; 
	float3 NormalizedWorldNormal = normalize(input.WorldNormal);

	float3 blend_weights = abs(NormalizedWorldNormal);     
	blend_weights = (blend_weights - tighten) * 7;  // Tighten up the blending zone
	blend_weights = max(blend_weights, 0);
	blend_weights /= (blend_weights.x + blend_weights.y + blend_weights.z).xxx; // Force weights to sum to 1.0 (very important!)  

	float scale = 0.2f;
	float dotResult = dot(UpNormal, NormalizedWorldNormal);

	float3 YZCoord;
	float3 XZCoord;
	float3 XYCoord;

	float4 XZColor;
	float4 YZColor;
	float4 XYColor;

	float worldPosY = input.WorldPosition.y;

	if(worldPosY <= 25.0f)
	{
		YZCoord = float3(input.WorldPosition.yz * scale, 2.0f);  
		XZCoord = float3(input.WorldPosition.xz * scale, 2.0f);  
		XYCoord = float3(input.WorldPosition.xy * scale, 2.0f);

		output.Normal.w = EncodeMaterialID(0.0f); //Set and save material to underground
	}
	else if(worldPosY <= 45.0f)
	{
		YZCoord = float3(input.WorldPosition.yz * scale, 2.0f);  
		XZCoord = float3(input.WorldPosition.xz * scale, 1.0f);  
		XYCoord = float3(input.WorldPosition.xy * scale, 2.0f);

		output.Normal.w = EncodeMaterialID(0.0f); //Set and save material to grass
	}
	else
	{
		YZCoord = float3(input.WorldPosition.yz * scale, 2.0f);  
		XZCoord = float3(input.WorldPosition.xz * scale, 4.0f);  
		XYCoord = float3(input.WorldPosition.xy * scale, 2.0f);
		
		output.Normal.w = EncodeMaterialID(0.0f); //Set and save material to snow
	}

	if(dotResult <= 0.1f) //If surface is facing downwards
	{
		XZCoord.z = 2.0f; //Then change surface texture to rock.
		
		//Set and save material to .. grass... Temporary material change until we get it tweaked properly
		output.Normal.w = EncodeMaterialID(0.0f); 
	}

	//We want to have a transitional phase between snow and grass.
	if(worldPosY >= 45.0f && worldPosY <= 46.0f)
	{
		float lerpModifier = (input.WorldPosition.y - 45.0f); //Meaning it goes from 0.0f to 1.0f
		float3 grassCoords = float3(input.WorldPosition.xz * scale, 1.0f);
		float3 snowCoords = float3(input.WorldPosition.xz * scale, 4.0f);

		YZColor = shaderTextures.Sample(textureSampler, YZCoord);
		XZColor = lerp(shaderTextures.Sample(textureSampler, grassCoords), shaderTextures.Sample(textureSampler, snowCoords), lerpModifier);
		XYColor = shaderTextures.Sample(textureSampler, XYCoord);

		output.Normal.w = EncodeMaterialID(0.0f);
	}
	else
	{
		YZColor = shaderTextures.Sample(textureSampler, YZCoord);
		XZColor = shaderTextures.Sample(textureSampler, XZCoord);
		XYColor = shaderTextures.Sample(textureSampler, XYCoord);
	}
	
	output.Color = ((XZColor * blend_weights.y) + (YZColor * blend_weights.x) + (XYColor * blend_weights.z));
	output.Color.w = 1.0f;

	output.Normal.xyz = Encode(NormalizedWorldNormal); //revert the normal output to [0,1] space then assign it to the output normal map's RGB channel
	output.Depth = (input.Depth.x / input.Depth.y);

	return output;
}

/*
// Determine the blend weights for the 3 planar projections.  
// N_orig is the vertex-interpolated normal vector.  
float3 blend_weights = abs( N_orig.xyz );   // Tighten up the blending zone:  
blend_weights = (blend_weights - 0.2) * 7;  
blend_weights = max(blend_weights, 0);      // Force weights to sum to 1.0 (very important!)  
blend_weights /= (blend_weights.x + blend_weights.y + blend_weights.z ).xxx;   

// Now determine a color value and bump vector for each of the 3  
// projections, blend them, and store blended results in these two  
// vectors:  
float4 blended_color; // .w hold spec value  

float3 blended_bump_vec;  
{ 
// Compute the UV coords for each of the 3 planar projections.  
// tex_scale (default ~ 1.0) determines how big the textures appear.  
float2 coord1 = v2f.wsCoord.yz * tex_scale;  
float2 coord2 = v2f.wsCoord.zx * tex_scale;  
float2 coord3 = v2f.wsCoord.xy * tex_scale; 
 
// This is where you would apply conditional displacement mapping.  
//if (blend_weights.x > 0) coord1 = . . .  
//if (blend_weights.y > 0) coord2 = . . .  
//if (blend_weights.z > 0) coord3 = . . .  

// Sample color maps for each projection, at those UV coords.  
float4 col1 = colorTex1.Sample(coord1);  
float4 col2 = colorTex2.Sample(coord2);  
float4 col3 = colorTex3.Sample(coord3);  

// Sample bump maps too, and generate bump vectors.  
// (Note: this uses an oversimplified tangent basis.)  
float2 bumpFetch1 = bumpTex1.Sample(coord1).xy - 0.5;  
float2 bumpFetch2 = bumpTex2.Sample(coord2).xy - 0.5;  
float2 bumpFetch3 = bumpTex3.Sample(coord3).xy - 0.5;  
float3 bump1 = float3(0, bumpFetch1.x, bumpFetch1.y);  
float3 bump2 = float3(bumpFetch2.y, 0, bumpFetch2.x);  
float3 bump3 = float3(bumpFetch3.x, bumpFetch3.y, 0);
  
 // Finally, blend the results of the 3 planar projections.  
blended_color = col1.xyzw * blend_weights.xxxx +  
				col2.xyzw * blend_weights.yyyy +  
				col3.xyzw * blend_weights.zzzz;

blended_bump_vec = bump1.xyz * blend_weights.xxx +  
				   bump2.xyz * blend_weights.yyy +  
				   bump3.xyz * blend_weights.zzz;  
}  
// Apply bump vector to vertex-interpolated normal vector.  
float3 N_for_lighting = normalize(N_orig + blended_bump);  
*/