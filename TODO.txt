
/********************************************************************************/
/*						TODO AND THINGS OF THAT SORT							*/
/********************************************************************************/

Fixes:

* SSAO Blur.

* New GUI system; ditch CEGUI

* TODO: Instead of a map... Maybe use four 2D vectors. One for -1-1, one for -1 1, one for 1 -1 and one for 1 1 ... should work fine

* Options screen...

* Depth only OBJ shader for shadow stage

* Non-simplex/perlin smooth noise
	-> Using this function, stuff like waves, marble etc will be possible

Features:

* Simple rain or snow screen shader

* Spotlight shader

* RTW shadowmapping < Cuz it's fuckin' awesome.

* Make geometry shader grass more fancy.
	-Should pretty much be finished now, just need to do the lookup-based-on-height thing.

* Particles
	-> Finally look into compute shader..?

* Water normal texture sliding thing that they do in arma2

########## Idea regarding vegetation lookup table ##################

First you have a lookup texture, a 1DTextureArray that has the same amount of textures as you have height in the world. You index into this texture array with the grassquad's worldPos.Y
Each texture has the first pixel allocated to the amount of textures ID there are for this height. So you read the first pixel value to know how many textures there are in this texture.
Then, when you know how many textures there are, you randomly select which texture you want to use. And then Load(1+(RandomVal*AmountOfTextures)). 
1+ because you don't want to use the first pixel in the texture.

Then you use the loaded texture ID to sample from your texture2DArray

###################################################################

Rendering and general layout of rendering system:
http://gamedev.stackexchange.com/questions/22080/which-of-these-directx11-calls-actually-sends-data-to-the-gpu
http://www.dataorienteddesign.com/dodmain/node14.html
http://www.bitsquid.se/presentations/benefits-of-a-data-driven-renderer.pdf

Directional light lens flare:
http://www.madgamedev.com/post/2010/04/21/Article-Sun-and-Lens-Flare-as-a-Post-Process.aspx
http://stackoverflow.com/questions/14161727/hlsl-drawing-a-centered-circle
if dot(cameraDirection, lightDirection) == -1 then they're both facing opposite ways I think

GPU Particles:
http://www.gamedev.net/topic/644489-gpu-particles/
http://directtovideo.wordpress.com/2009/10/06/a-thoroughly-modern-particle-system/
http://realtimecollisiondetection.net/blog/?p=91
http://http.developer.nvidia.com/GPUGems3/gpugems3_ch23.html

*/

TODO: Slerp.

// Special Thanks to Johnathan, Shaun and Geof!
Vector3 Slerp(Vector3 start, Vector3 end, float percent)
{
	 // Dot product - the cosine of the angle between 2 vectors.
	 float dot = Vector3.Dot(start, end);     
	 // Clamp it to be in the range of Acos()
	 // This may be unnecessary, but floating point
	 // precision can be a fickle mistress.
	 Mathf.Clamp(dot, -1.0f, 1.0f);
	 // Acos(dot) returns the angle between start and end,
	 // And multiplying that by percent returns the angle between
	 // start and the final result.
	 float theta = Mathf.Acos(dot)*percent;
	 Vector3 RelativeVec = end - start*dot;
	 RelativeVec.Normalize();     // Orthonormal basis
	 // The final result.
	 return ((start*Mathf.Cos(theta)) + (RelativeVec*Mathf.Sin(theta)));
}
