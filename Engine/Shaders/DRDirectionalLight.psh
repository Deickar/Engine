/////////////////////////////////////////////
//////////////////INPUT//////////////////////
/////////////////////////////////////////////

cbuffer PositionalBuffer //Whatever, idk what else to name it
{
	float4 LightDirection;
	float4 CameraPosition;
};

cbuffer PixelMatrixBuffer
{
	float4x4 InvertedView;
	float4x4 LightView;
	float4x4 LightViewProj;
};

cbuffer LightBuffer
{
	float4 DiffuseColor;
	float4 AmbientColor;
};

//static const float CameraFarClip = 400.0f;

SamplerState linearSampler : register(s0);
SamplerState anisotropicSampler : register(s1);
SamplerComparisonState cmpSampler : register(s2);

Texture1DArray materialArray;
Texture2D shaderTextures[4]; // 0 = normal, 1 = standard depth, 2 = shadowmap depth, 3 = color map.

struct VertexShaderOutput
{
	float4 Position : SV_POSITION;
	float4 ScreenPosition : TEXCOORD0;
	float2 TexCoord : TEXCOORD1;
	float3 ViewPosition : TEXCOORD2;
};

/////////////////////////////////////////////
////////////UTILITY FUNCTIONS////////////////
/////////////////////////////////////////////
void RetrieveMaterialData(int materialID, out float ambienceCoefficient, out float diffuseCoefficient, 
	out float specularCoefficient, out float surfaceSmoothness) // out bool recieveShadows
{
	/*
	Because the runtime does not support 1D textures, the compiler will use a 2D texture with the knowledge 
	that the y-coordinate is unimportant. Since tex1D(s, t) (DirectX HLSL) is implemented as a 2D texture lookup, 
	the compiler is free to choose the y-component in an efficient manner.
	*/

	int3 LoadingCoordinates = int3(0, materialID, 0);

	//Load all of the coefficients and assign them to local variables
	ambienceCoefficient = materialArray.Load(LoadingCoordinates);
	LoadingCoordinates.x += 1;

	diffuseCoefficient = materialArray.Load(LoadingCoordinates);
	LoadingCoordinates.x += 1;

	specularCoefficient = materialArray.Load(LoadingCoordinates);
	LoadingCoordinates.x += 1;

	surfaceSmoothness = materialArray.Load(LoadingCoordinates);
	LoadingCoordinates.x += 1;

	////Kind of a crude way to store a bool, but it works.
	//recieveShadows = ((materialArray.Load(LoadingCoordinates)) >= 0.5f ? true : false);
	//LoadingCoordinates.x += 1;
}

//Decoding of GBuffer Normals
half3 DecodeNormal(half2 enc)
{
	half2 fenc = enc*4-2;
	half f = dot(fenc,fenc);
	half g = sqrt(1-f/4);
	half3 n;
	n.xy = fenc*g;
	n.z = 1-f/2;
	return n;
}

float3 ReconstructViewPositionFromDepth(float3 viewRay, float depth, float farClip)
{
	return float3(viewRay.xy * (farClip / viewRay.z), farClip) * depth;
}


float3 ReconstructWorldPositionFromDepth(float3 viewRay, float depth)
{
	return CameraPosition.xyz + (viewRay * (depth*400.0f));
}

/////////////////////////////////////////////
/////////////SHADOW FUNCTIONS////////////////
/////////////////////////////////////////////

//Calculate shadow contribution using chevyshev's inequality.
float ChebyshevUpperBound(float2 moments, float t)  
{
	float minVariance = 0.002f; //Scaling value.

	// Compute variance.  
	float variance = moments.y - (moments.x*moments.x);
	variance = max(variance, minVariance);

	// Compute probabilistic upper bound.  
	float d = (t - moments.x);
	float p_max = (variance / (variance + d*d));

	return p_max;
}


float ShadowContribution(float2 lightTexCoord, float distanceToLight)  
{
	// Read the moments from the variance shadow map.  
	float2 moments = shaderTextures[2].Sample(anisotropicSampler, lightTexCoord).rg;

	//If surface is fully lit, break early.
	if(distanceToLight <= moments.x)
	{
		return 1.0f;
	}

	// Compute the Chebyshev upper bound.
	return ChebyshevUpperBound(moments, distanceToLight);
}


/////////////////////////////////////////////
///////////////MAIN FUNCTION/////////////////
/////////////////////////////////////////////

float4 LightPixelShader(VertexShaderOutput input) : SV_Target0
{
	//http://gamedev.stackexchange.com/questions/29447/could-someone-explain-why-my-world-reconstructed-from-depth-position-is-incorrec

	//Sample camera depth
	float depth = shaderTextures[1].Sample(linearSampler, input.TexCoord);

	if(depth == 0.0f)
	{
		return AmbientColor; //0 0 0 0. We break really early for optimization, and to not apply directional light to the sky sphere...
	}

	float ambienceCoefficient, diffuseCoefficient, specularCoefficient, surfaceSmoothness;
	//bool recieveShadows = false; //Used to combat self-shadowing.
	float3 finalDiffuseProduct = float3(0.0f, 0.0f, 0.0f);
	float finalSpecularProduct = 0.0f;
	float LightIntensity = LightDirection.w;

	float4 encodedNormal = shaderTextures[0].Sample(anisotropicSampler, input.TexCoord);

	//http://gamedev.stackexchange.com/questions/22864/enconding-decoding-bit-value-in-texture-alpha-channel
	//We recreate the material IDs
	int materialID = round(encodedNormal.z * 255);
	int materialID2 = round(encodedNormal.w * 255);

	RetrieveMaterialData(materialID, ambienceCoefficient, diffuseCoefficient, specularCoefficient, surfaceSmoothness);

	//If there's a difference between our two materials, we have to lerp!
	if(materialID != materialID2) 
	{
		float lerpVal = shaderTextures[3].Sample(linearSampler, input.TexCoord).w;
		float ambienceCoefficient2, diffuseCoefficient2, specularCoefficient2, surfaceSmoothness2;

		RetrieveMaterialData(materialID2, ambienceCoefficient2, diffuseCoefficient2, specularCoefficient2, surfaceSmoothness2);

		ambienceCoefficient =	lerp(ambienceCoefficient, ambienceCoefficient2, lerpVal);
		diffuseCoefficient =	lerp(diffuseCoefficient, diffuseCoefficient2, lerpVal);
		specularCoefficient =	lerp(specularCoefficient, specularCoefficient2, lerpVal);
		surfaceSmoothness =		lerp(surfaceSmoothness, surfaceSmoothness2, lerpVal);
	}

	float3 normal = normalize(DecodeNormal(encodedNormal.xy));

	//Surface-to-light vector
	float3 lightVector = (-LightDirection);

	//Calculate diffuse intensity, the usual
	float NdL = dot(lightVector, normal);

	//Reconstructing world position
	float4 position = mul(float4(ReconstructViewPositionFromDepth(input.ViewPosition, depth, CameraPosition.w), 1.0f), InvertedView);
	position /= position.w;

	//Extract pixel position as seen from light POV for shadow map extraction.
	float4 lightScreenPos = mul(position,  LightViewProj);
	float realDistanceToLight = mul(position, LightView).z/CameraPosition.w;

	lightScreenPos.xy = 0.5 * lightScreenPos.xy / lightScreenPos.w + float2(0.5f, 0.5f);
	lightScreenPos.y = 1.0f - lightScreenPos.y;

	float shadowMultiplier = 1.0f;

	//We cull a large part of the light and shadow calculations if it's outside of the light frustum.
	if
	(		
		!(	lightScreenPos.x >= 0.99f || lightScreenPos.x <= 0.01f	|| 
			lightScreenPos.y >= 0.99f || lightScreenPos.y <= 0.01f	)
	)
	{
		/*Variance shadow mapping. http://http.developer.nvidia.com/GPUGems3/gpugems3_ch08.html */
		shadowMultiplier = ShadowContribution(lightScreenPos.xy, realDistanceToLight);
	}	

	//If we aren't in shadow and surface angle is satisfactory, calculate specular
	if(NdL > 0.0f)
	{
		//Reflection vector
		float3 reflectionVector = normalize(reflect(lightVector, normal));

		//surface-to-camera vector
		float3 directionToCamera = normalize(position.xyz - CameraPosition.xyz);

		//Calculate specular light 
		finalSpecularProduct += specularCoefficient * pow( saturate( dot(reflectionVector, directionToCamera)), surfaceSmoothness);

		//Calculate diffuse light
		finalDiffuseProduct += diffuseCoefficient * (NdL * DiffuseColor.rgb);
	}

	return float4((ambienceCoefficient * AmbientColor.rgb) + (finalDiffuseProduct * shadowMultiplier), (finalSpecularProduct * shadowMultiplier)) * LightIntensity;
}

/*
http://www.gamedev.net/topic/544909-view-space-directional-light/
*/


	//float4 finalAmbienceProduct = ambienceCoefficient * AmbientColor;

	//float3 worldNormal = DecodeNormal(encodedNormal.xy);
	//float3 normalVS = normalize(mul(worldNormal, View));

	////Surface-to-light vector
	//float3 LightDirectionVS = normalize(mul(-LightDirection, View));

	////Calculate diffuse intensity, the usual
	//float NdL = saturate(dot(normalVS, LightDirectionVS));
	//float UpDotN = dot(worldNormal, float3(0.0f, 1.0f, 0.0f));

	//float4 viewPosition = float4(ReconstructViewPositionFromDepth(input.ViewPosition.xyz, depth), 1.0f);

	////Reconstructing position in worldspace
	//float4 worldPosition = mul(viewPosition, InvertedView);

	////Extract pixel position as seen from light POV for shadow map extraction.
	//float4 lightScreenPos = mul(worldPosition, LightView);

	////Adjust from [-1,1] range to [0,1] range
	//lightScreenPos.x = ((lightScreenPos.x * 0.5f) + 0.5f);
	//lightScreenPos.y = ((-lightScreenPos.y * 0.5f) + 0.5f);

	//float shadowMultiplier = 1.0f;

	////We cull a large part of the light and shadow calculations if it's outside of the light frustum.
	////Using 0.99 and 0.01 because if I use 1.0 and 0.0, I get black lines along the extreme edge of the light frustum
	//if
	//(		
	//	!(	lightScreenPos.x >= 0.99f || lightScreenPos.x <= 0.01f	|| 
	//		lightScreenPos.y >= 0.99f || lightScreenPos.y <= 0.01f	)
	//)
	//{
	//	/*Variance shadow mapping. http://http.developer.nvidia.com/GPUGems3/gpugems3_ch08.html */
	//	shadowMultiplier = ShadowContribution(lightScreenPos.xy, viewPosition.z);
	//}


	//if(UpDotN > 0.0f)
	//{
	//	///*PHONG*/
	//	////Reflection vector
	//	////DONOT USE -lightDir since the reflection returns a ray from the surface
	//	//float3 reflectionVector = normalize(reflect(LightDirectionVS, normalVS));

	//	////Calculate specular light 
	//	//finalSpecularProduct += specularCoefficient * pow( saturate( dot(reflectionVector, -normalize(input.ViewRay))), surfaceSmoothness);
	//	///*End of phong*/

	//	/*BLINN-PHONG*/
	//	float3 H = normalize( LightDirectionVS + input.ViewPosition.xyz );

	//	//Calculate specular light 
	//	finalSpecularProduct += specularCoefficient * pow( saturate( dot(normalVS, H)), surfaceSmoothness);
	//	/*End of blinn phong*/

	//	//Calculate diffuse light
	//	finalDiffuseProduct += diffuseCoefficient * (NdL * DiffuseColor.rgb);
	//}


	////Essentially I save a float in the normal render target's .w channel that decides if the object should be shaded or not.
	////I do this because of how the vegatation quads are built -- they each consist of three different quads, and they all shade eachother.
	////This results in the quads looking really ass, and they also start flickering when the light moves and shit. Bad.

	//if(recieveShadows)
	//{
	//	return (LightIntensity*float4(finalAmbienceProduct.rgb + (finalDiffuseProduct * shadowMultiplier), (finalSpecularProduct * shadowMultiplier)));
	//}
	//else //Don't shade if it shouldn't recieve any shadows.
	//{
	//	return (LightIntensity*float4(finalAmbienceProduct.rgb + finalDiffuseProduct, finalSpecularProduct));
	//}