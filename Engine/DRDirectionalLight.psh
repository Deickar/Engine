cbuffer PositionalBuffer //Whatever, idk what else to name it
{
	float4 LightDirection;
	float4 LightPosition;
	float4 CameraPosition;
};

cbuffer PixelMatrixBuffer
{
	float4x4 InverseViewProjection;
};

cbuffer LightBuffer
{
	float4 DiffuseColor;
	float4 AmbientColor;

	float Ka; //Ambient light coefficient
	float Kd; //Diffuse light coefficient
	float Ks; //Specular light coefficient
	float a; //Alpha coefficient
};

SamplerState samplers[2]; //0 == linear, 1 == point
Texture2D shaderTextures[2]; // 0 = normal, 1 = standard depth.

struct VertexShaderOutput
{
		float4 Position : SV_POSITION;
		float2 TexCoord : TEXCOORD0;
		float4 ViewPosition : TEXCOORD1;
};

//Decoding of GBuffer Normals
float3 decode(float3 enc)
{
	return (2.0f * enc.xyz- 1.0f);
}

half4 LightPixelShader(VertexShaderOutput input) : SV_Target
{
		float depth = shaderTextures[1].Sample(samplers[1], input.TexCoord);

		if(0 >= depth) //Skip as early as possible if this pixel isn't supposed to be lit.
		{
			return float4(0.0f, 0.0f, 0.0f, 0.0f);
		}

		//compute ambient light
		half4 finalAmbienceProduct = half4(0.0f, 0.0f, 0.0f, 0.0f);
		finalAmbienceProduct += Ka * AmbientColor;

		float4 encodedNormal = shaderTextures[0].Sample(samplers[0], input.TexCoord);

		float3 normal = normalize(decode(encodedNormal.xyz));

		float4 position;
		position = float4(input.Position.xyz * depth, 1.0f);

		position = mul(position, InverseViewProjection);
		//position /= position.w;
	
		//surface-to-light vector
		float3 lightVector = -normalize(LightDirection); //Sigh, idk
		float NdL = max(0, dot(lightVector, normal));

		//reflection vector
		float3 reflectionVector = normalize(-reflect(lightVector, normal));

		//camera-to-surface vector
		float3 directionToCamera = normalize(position-CameraPosition);

		//compute diffuse light
		half4 finalDiffuseProduct = half4(0.0f, 0.0f, 0.0f, 0.0f);
		finalDiffuseProduct.xyzw += Kd * NdL;

		//compute specular light 
		float finalSpecularProduct = 0.0f;
		finalSpecularProduct += Ks * pow( saturate(dot(directionToCamera, reflectionVector)), a);
		
		//Storing specular in alpha channel. Applying shadow multiplier to both diffuse product and specular, but not ambient, to make sure it's not just black.
		return half4(finalAmbienceProduct.rgb + (DiffuseColor.rgb*finalDiffuseProduct.rgb), finalSpecularProduct);
}


/*


float4 ps_lighting(VS_OUTPUT IN) : SV_Target
{
	if (renderingSkel || renderingRBody)
	{
		return float4(1, 1, 1, 1);
	}
	else
	{
		//shadow mapping stuff
		IN.LightPosition.xyz /= IN.LightPosition.w;
		
		float4 ambient = ambientBright * materialAmbient;

		if( IN.LightPosition.x < -1.0f || IN.LightPosition.x > 1.0f || IN.LightPosition.y < -1.0f || IN.LightPosition.y > 1.0f || IN.LightPosition.z < 0.0f  || IN.LightPosition.z > 1.0f ) 
			return ambient;

		IN.LightPosition.x = IN.LightPosition.x/2 + 0.5;
		IN.LightPosition.y = IN.LightPosition.y/-2 + 0.5;

		float shadowMapDepth = shadowMap.Sample(ShadowSampler, IN.LightPosition.xy).r;

		if (shadowMapDepth < IN.LightPosition.z) return ambient;

		float3 V = normalize(IN.eye - IN.position);
		float3 R = reflect(lightDir, IN.normal);
		
		float4 diffuse = diffuseBright * (materialDiffuse * saturate(dot(lightDir, IN.normal)));
		float4 specular = specularBright * pow(saturate(dot(R, V)), normalize(shine));
		float4 finalColor = ambient + diffuse;
		if (shine > 0)
		{
			finalColor = saturate(finalColor + specular);
		}

		

		float4 color = texDiffuse.Sample(DiffuseSampler, IN.tex0);
		float4 sphCol = sphTexture.Sample(SphereSampler, IN.spTex);
		if (useTexture)
		{
			finalColor *= color;
		}
		if (useSphere)
		{
			if (isSphereAdd)
			{
				finalColor += sphCol;
			}
			else
			{
				finalColor *= sphCol;
			}
		}
		float4 o = (finalColor * extraBright) * fadeCoef;
		if (useTexture)
		{
			o.a = color.a * materialDiffuse.a;
		}
		else
		{
			o.a = materialDiffuse.a;
		}
		return o;
	}
}


*/