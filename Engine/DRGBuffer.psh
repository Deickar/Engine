cbuffer PixelShaderBuffer
{
	float FarZ;
	float3 Padding;
};

struct VertexShaderOutput
{
	float4 Position : SV_POSITION;
	float3 Normal : NORMAL;
	float2 TexCoord : TEXCOORD0;
	float4 ViewPosition : TEXCOORD1;
	float4 WorldPosition : TEXCOORD2;
	float3x3 TangentToWorld : TEXCOORD3;
};

struct PixelShaderOutput
{
	half4 Color : SV_TARGET0; //R8G8B8A8
	half4 Normal : SV_TARGET1; //R8G8B8A8
	float Depth : SV_TARGET2; //R32
};

Texture2D shaderTextures[3]; //0 == diffuse, 1 == specular, 2 == normal

SamplerState linearSampler : register(s0); //This can be used for all 3 different textures, seeing as they're all sampled the same way!

//Normal Encoding Function
half3 encode(half3 n)
{
	n.xyz = 0.5f * (n.xyz + 1.0f);

	return n;
}

PixelShaderOutput GBufferPixelShader(VertexShaderOutput input)
{
	PixelShaderOutput output;

	//Create weights for color interpolation based on world-space normal of surface
	float tighten = 0.2f; 
	float mXY = abs(input.Normal.z)-tighten;
	float mXZ = abs(input.Normal.y)-tighten;
	float mYZ = abs(input.Normal.x)-tighten;

	//Then we make their sum equal to one (this is important because we don't want to add or 
	//remove any color from the original texture):
	float total = mXY + mXZ + mYZ;
	mXY /= total;
	mXZ /= total;
	mYZ /= total;

	float scale = 0.5f;
	
	float4 cXY = shaderTextures[0].Sample(linearSampler, input.WorldPosition.xy * scale);
	float4 cXZ = shaderTextures[0].Sample(linearSampler, input.WorldPosition.xz * scale);
	float4 cYZ = shaderTextures[0].Sample(linearSampler, input.WorldPosition.yz * scale);

	output.Color =	cXY*mXY + cXZ*mXZ + cYZ*mYZ; 
	//output.Color = shaderTextures[0].Sample(linearSampler, input.TexCoord);
	float3 normalFromMap =				shaderTextures[1].Sample(linearSampler, input.TexCoord);
	float4 specularAttributes =		shaderTextures[2].Sample(linearSampler, input.TexCoord);

	//if(output.Color.a < 0.45f) //Crude alpha testing
	//{
	//	output.Color = float4(0.0f, 0.0f, 0.0f, 0.0f);
	//}

	float specularIntensity = 1.0f;
	float specularPower = 128.0f;


	output.Color.w = specularAttributes.x; //store specular intensity value in color target's alpha value

	normalFromMap = normalFromMap * 2.0f - 1.0f;				//tranform the normal data from [0,1] to [-1,1]
	normalFromMap = mul(normalFromMap, input.TangentToWorld);	//transform it into world space
	normalFromMap = normalize(normalFromMap);					//then normalize the result

	output.Normal.xyz = encode(normalFromMap);			//revert the normal output to [0,1] space then assign it to the output normal map's RGB channel

	output.Normal.w = specularAttributes.y; //specular power stored in normal map's alpha channel

	output.Depth.x = (input.ViewPosition.z / FarZ);
	//output.Depth = 1.0f - (input.Position.z / input.Position.w);

	return output;
}
