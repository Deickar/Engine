/////////////
// GLOBALS //
/////////////
Texture2DArray shaderTexture;
SamplerState linearSampler;

//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
	float4 Position : SV_POSITION;
	float4 TexCoord : TEXCOORD0;
};

struct PixelShaderOutput
{
	half4 Color : SV_TARGET0; //R8G8B8A8
	half4 Normal : SV_TARGET1; //R8G8B8A8
	float Depth : SV_TARGET2; //R32
};

////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
PixelShaderOutput VegetationQuadPixelShader(PixelInputType input)
{
	PixelShaderOutput output;

	output.Color = half4(0.0f, 0.0f, 0.0f, 0.0f);
	half4 tempColor = output.Color;

	float3 samplingCoords = float3(input.TexCoord.xy, input.TexCoord.w); //Add textureID from TexCoord.w to Z channel so that we can sample dynamically

	tempColor = shaderTexture.Sample(linearSampler, samplingCoords); //No branching cuz texture array. Yay.

	if(tempColor.a >= 0.2f)
	{
		output.Color.xyz = tempColor.xyz;
		output.Color.a = 1.0f;
	}
	
	output.Depth = (input.TexCoord.z); //We stored postProj.zw in TexCoord.zw to save one register slot of space.

	output.Normal = (0.5f * float4(0.0f, 1.0f, 0.0f, 1.0f) + 1.0f);

	//This is the "Should this pixel recieve shadows" value. >= 1.0f means yes.
	output.Normal.w = 0.0f;

	return output;
}