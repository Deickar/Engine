rendering:
{
		farClip = 400.0;
		nearClip = 2.0;
		wireframe = FALSE;
		shadowmapWidth = 1024.0;
		shadowmapHeight = 1024.0;

		windowWidth = 1024.0; 
		windowHeight = 768.0;
		fullscreen = FALSE;
}

shaders:
{
	gbufferModel:
	{
		textureScale = 0.2;
		tighten = 0.45;	
	}

	gbufferTerrain:
	{
		tighten = 0.5;
		textureScale = 0.15;
	}

	waterShader:
	{
		positionSamplingOffset = 0.2;
		heightScaling = 0.3;
		timeScaling = 0.12;
		waterLevels = 5.0; //This is the height value where the water will end

		waterColorStartOffset = 0.2; //Algorithm is: colorMultiplier = waterColorStartOffset + (heightValue*waterColorMultiplier)
		waterColorMultiplier = 0.8;
	}

	grassShader:
	{
		grassMinimumHeightLevel = 6.0; //Grass won't grow below this height
		grassMaximumHeightLevel = 100.0; //Grass won't grow above this height
		vegetationScale = 1.3;
		vegetationFalloff = 450.0;
		forceScale = 0.4;
		waveLength = 0.8;
		traversalSpeed = 0.12;
		
		//How far from the ground vertex the grass can "grow". 
		//If it's set to 0.0 it will always grow exactly where the vertex is. This results in straight rows of grass and looks very unnatural.
		//However, it depends on the terrain. If it's very hilly with a lot of water and stuff it actually looks natural anyway, because the height differences break it all up.
		positionalRandomDeviance = 1.0; 

		//How far in any direction the upper quad vertices are allowed to "lean". 
		//If it's set to 0.0 it will always stand straight up. It'll still be moved by wind, though, unless forceScale is set to 0.0.
		angularRandomDeviance = 0.2;

		//We calculate slope scale by doing dot(upNormal, surfaceNormal). If it's higher than acceptableSlopeScale then we render grass there.
		acceptableSlopeScale = 0.85; 
	}

	composeShader:
	{
		sampleRadius = 0.1; //Controls sampling radius. 0.1f to 1.0f are pretty ok values.
		intensity = 6.0; //AO intensity. The higher this value is, the darker the occluded parts will be. 1.0f to 10.0f values is pretty ok values.
		scale = 0.2; //Scales distance between occluders and occludee. Still a little unsure as to what values would be good to use.
		bias = 0.05; //Cutoff value. The higher this value is, the harsher we are with cutting off low AO values. 0.01f to 0.4f values are pretty ok.
		FogStart = 150.0;
		FogEnd = 300.0;
	}
}

frustum:
{
	//fov, aspect ratio, etcetc
}

camera:
{
	positionX = 0.0; 
	positionY = 90.0;
	positionZ = 0.0;

	turnSpeed = 0.06;
	sprintModifier = 3.0;
	sneakModifier = 0.3;

	collisionRadius = 2.5;
	mass = 0.1;
	
	forceScale = 250.0;
	restitution = 0.0;
	friction = 0.8;
	anisotropicFriction = 1.0;

	//Set to 0.99 and reduce forceScale to a tenth of current value to fix clipping through walls. Only problem is that then the camera slides when you stop it.
	lineardamping = 1.0;
	angulardamping = 5.0;
}

physics:
{
	timeStep = 0.00833333333; // 1 / 120       0.00555555555; //1 / 180
	maxSubsteps = 15;
	gravityX = 0.0; 
	gravityY = 0.0; 
	gravityZ = 0.0;
}

windsystem:
{
	updateThreshold = 10.0;
	changeAmplitude = 100.0;
}

textures:
{
	windTextureWidth = 1024.0;
	windTextureHeight = 1024.0;

	ssaoNoiseTextureWidth = 64.0;
	ssaoNoiseTextureHeight = 64.0;
}

daycycle:
{
	timePerStage = 300.0; //Seconds.

	stagesOfDay = 
	( 
		{ 
			/*Dawn.*/
			lightColorR = 0.3;
			lightColorG = 0.3;
			lightColorB = 0.3;

			skysphereColorR = 255.0;
			skysphereColorG = 160.0;
			skysphereColorB = 122.0;

			startPosX = 150.0;
			startPosY = 45.0;
			startPosZ = 15.0;

			endPosX = 75.0;
			endPosY = 65.0;
			endPosZ = 30.0;

			durationMultiplier = 1.0;
			lightIntensity = 0.7;
		},
		{ 
			/*Morning.*/
			lightColorR = 0.5;
			lightColorG = 0.5;
			lightColorB = 0.5;

			skysphereColorR = 180.0;
			skysphereColorG = 150.0;
			skysphereColorB = 180.0;

			startPosX = 75.0;
			startPosY = 65.0;
			startPosZ = 30.0;

			endPosX = 35.0;
			endPosY = 90.0;
			endPosZ = 70.0;

			durationMultiplier = 1.0;
			lightIntensity = 0.85;
		},
		{ 
			/*Day. Yellow sunshine: 231 187 65 */
			lightColorR = 0.7;
			lightColorG = 0.7;
			lightColorB = 0.7;

			skysphereColorR = 100.0;
			skysphereColorG = 140.0;
			skysphereColorB = 237.0;

			startPosX = 35.0;
			startPosY = 90.0;
			startPosZ = 70.0;

			endPosX = -35.0;
			endPosY = 90.0;
			endPosZ = 50.0;

			durationMultiplier = 3.0; /* Make day three times as long other stages. */
			lightIntensity = 1.0;
		},
		{ 
			/*Dusk.*/
			lightColorR = 0.5;
			lightColorG = 0.5;
			lightColorB = 0.5;

			skysphereColorR = 50.0;
			skysphereColorG = 180.0;
			skysphereColorB = 170.0;

			startPosX = -35.0;
			startPosY = 90.0;
			startPosZ = 50.0;

			endPosX = -75.0;
			endPosY = 65.0;
			endPosZ = 30.0;

			durationMultiplier = 1.0;
			lightIntensity = 0.85;
		},
		{ 
			/*Evening.*/
			lightColorR = 0.3;
			lightColorG = 0.3;
			lightColorB = 0.3;

			skysphereColorR = 45.0;
			skysphereColorG = 67.0;
			skysphereColorB = 74.0;

			startPosX = -75.0;
			startPosY = 65.0;
			startPosZ = 30.0;

			endPosX = -150.0;
			endPosY = 45.0;
			endPosZ = 15.0;

			durationMultiplier = 1.0;
			lightIntensity = 0.7;
		},
		{ 
			/*Night.*/
			lightColorR = 0.3;
			lightColorG = 0.3;
			lightColorB = 0.3;

			//Moonlight color: 217 206 190
			skysphereColorR = 15.0;
			skysphereColorG = 15.0;
			skysphereColorB = 30.0;

			//Morning start pos
			startPosX = 150.0;
			startPosY = 45.0;
			startPosZ = 15.0;

			//Evening end pos
			endPosX = -150.0;
			endPosY = 45.0;
			endPosZ = 15.0;

			//Evening lasts pretty much as long as the others combined.
			durationMultiplier = 7.0;
			lightIntensity = 0.5;
		}
	);
}


filepaths:
{
	shaders = "../Engine/Shaders/";
	content = "../Engine/data/";
	vegetation = "../Engine/data/CGTextures/Vegetation/";
	cegui = "../CEGUI/datafiles/";
}

terrain:
{
	//enum TerrainTypes
	
	//	SeaBottom = 0,
	//	Plains,
	//	Hills,
	//	Terraces,
	//	DramaticHills,
	//	FlyingIslands,
	//	Alien,
	//	Fancy,
	//	Cave,
	//	Flat,
	//	TERRAINTYPES_LIST_SIZE //Always keep last

	
	//Voxels per chunk?
	//Stepsize? TODO

	startingTerrainType = 4;
}
