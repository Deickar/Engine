struct VertexShaderOutput
{
	float4 Position : SV_POSITION;
	float3 ViewPosition : TEXCOORD0;
};

float2 ComputeMoments(float depth)  
{ 
	float2 moments;
	 
	// First moment is normal depth.  
	moments.x = depth;

	// Compute partial derivatives of depth.  
	float dx = ddx(depth);  
	float dy = ddy(depth);

	// Compute second moment over the pixel extents.  
	moments.y = depth*depth + 0.25*(dx*dx + dy*dy);

	return moments;
};

float2 DepthOnlyPixelShader(VertexShaderOutput input) : SV_Target0
{
	return ComputeMoments((input.ViewPosition.z / 150.0f));
};


/*
From Matt Perineo's blog: http://mynameismjp.wordpress.com/2010/09/05/position-from-depth-3/

Here’s what the code might look like for doing it in world space (since people seem to like sticking to world space, despite the advantages of view space):

***************************
// G-Buffer vertex shader
***************************
// Calculate view space position of the vertex and pass it to the pixel shader
output.PositionVS = mul(input.PositionOS, WorldViewMatrix).xyz;

***************************
// G-Buffer pixel shader
***************************
// Calculate the length of the view space position to get the distance from camera->surface
output.Distance.x = length(input.PositionVS);


***************************
// Light vertex shader
***************************
#if PointLight || SpotLight

// Calculate the world space position for a light volume
float3 positionWS = mul(input.PositionOS, WorldMatrix);

#elif DirectionalLight

// Calculate the world space position for a full-screen quad (assume input vertex coordinates are in [-1,1] post-projection space)
float3 positionWS = mul(input.PositionOS, InvViewProjMatrix);
#endif


// Calculate the view ray
output.ViewRay = positionWS - CameraPositionWS;


***************************
// Light Pixel shader
***************************
// Normalize the view ray, and apply the original distance to reconstruct position
float3 viewRay = normalize(input.ViewRay);

float viewDistance = DistanceTexture.Sample(PointSampler, texCoord);

float3 positionWS = CameraPositionWS + viewRay * viewDistance;Like I said it’s piece of cake, and I suspect that for a lot of people it’s efficient enough. 
But we’re not done yet, since we can still optimize things further if we stick to view space. We also want  may want to use a hardware depth buffer as opposed to manually storing a distance value.

*/