struct VertexShaderOutput
{
		float4 Position : SV_POSITION;
		float4 ScreenPosition : TEXCOORD0;
		float2 TexCoord : TEXCOORD1;
};

SamplerState samplers[2]; //0 == linear sampler, 1 == point
Texture2D randomTexture : register(ps_5_0, t0);
Texture2D shaderTextures[4] : register(ps_5_0, t1); // 0 = color, light = 1, 2 = depth, 3 = normal

static const float sampleRadius = 1.5f;
static const float intensity = 3.0f;
static const float scale = 3.0f;
static const float bias = 0.1f;

cbuffer PixelMatrixBufferType
{
	float4x4 InvViewProjection;
}

//Decoding of GBuffer Normals
float3 DecodeNormal(float3 enc)
{
	return ((2.0f * enc.xyz) - 1.0f);
}

float4 ReconstructPositionFromDepth(float depth, float2 ScreenPosition)
{
	//Create a clip space position (I think?)
	float4 position;
	position.xy = ScreenPosition;
	position.z = depth; //With depth from camera
	position.w = 1.0f;

	position = mul(position, InvViewProjection); //And revert it back to world position
	position /= position.w;

	return position;
}

float DoAmbientOcclusion(float2 TexCoord, float2 Offset, float2 ScreenPos, float3 Position, float3 Normal)
{
	float offsetDepth = shaderTextures[2].Sample(samplers[0], (TexCoord + Offset));
	float3 offsetPosition = ReconstructPositionFromDepth(offsetDepth, ScreenPos).xyz;

	float3 diff = offsetPosition - Position;
	float3 v = normalize(diff);
	float d = length(diff)*scale;

	return max(0.0, dot(Normal, v)-bias)*(1.0/(1.0+d))*intensity;
}

float4 ComposePixelShader(VertexShaderOutput input) : SV_Target0
{
		float depth = shaderTextures[2].Sample(samplers[1], input.TexCoord);
		float fogFactor = 0.0f;
		float3 baseColor = shaderTextures[0].Sample(samplers[0], input.TexCoord).rgb;
		float FogEnd = 150.0f;
		float FogStart = 149.8f;
		half4 FogColor = half4(0.6f, 0.6f, 0.6f, 1.0f);
		float2 screenSize = float2(1024, 768);
		float2 randomSize = float2(64, 64);

		if(depth <= 0.0001f) //Skip as early as possible if this pixel isn't supposed to be lit.
		{
			return float4(baseColor, 1.0f);
		}

		depth = (depth*150.0f);

		fogFactor = saturate((depth - FogStart) / (FogEnd - FogStart));

		//FOG:
		//http://www.iquilezles.org/www/articles/ssao/ssao.htm
		//http://jcoluna.wordpress.com/2012/11/06/xna-adding-fog-in-a-lpp-or-deferred-pipeline/
		//http://cloneofduty.com/2012/07/30/deferred-rendering-5-foggy-haze/

		//SSAO:
		//http://www.gamedev.net/page/resources/_/technical/graphics-programming-and-theory/a-simple-and-practical-approach-to-ssao-r2753
		
		const float2 vec[4] = {	float2(1,0),float2(-1,0),
								float2(0,1),float2(0,-1) };

		float3 position = ReconstructPositionFromDepth(depth, input.ScreenPosition.xy).xyz;
		float3 normal = normalize(DecodeNormal(shaderTextures[3].Sample(samplers[0], input.TexCoord).xyz));

		//return normalize(tex2D(g_random, g_screen_size * uv / random_size).xy * 2.0f - 1.0f);
		float2 rand = normalize(randomTexture.Sample(samplers[0], (screenSize*input.TexCoord / randomSize)).xy * 2.0f - 1.0f);

		float ao = 0.0f;
		float rad = sampleRadius/position.z;


		int iterations = 2; //lerp(6, 1, (position.z/150.0f)); //primitive SSAO LOD; Divide p.z with farClip

		//SSAO Calculation
		[unroll]
		for (int i = 0; i < iterations; i++)
		{
			float2 coord1 = reflect(vec[i], rand)*sampleRadius;
			float2 coord2 = float2(	coord1.x*0.707f - coord1.y*0.707f,
									coord1.x*0.707f + coord1.y*0.707f);
  
			ao += DoAmbientOcclusion(input.TexCoord, coord1*0.25f,	input.ScreenPosition.xy, position, normal);
			ao += DoAmbientOcclusion(input.TexCoord, coord2*0.5f,	input.ScreenPosition.xy, position, normal);
			ao += DoAmbientOcclusion(input.TexCoord, coord1*0.75f,	input.ScreenPosition.xy, position, normal);
			ao += DoAmbientOcclusion(input.TexCoord, coord2,		input.ScreenPosition.xy, position, normal);
		}
		
		ao /= (float)iterations*4.0f;

		ao = max((1.0f - ao), 0.0f);

		//Add AO to final calculation ...
		

		//specular intensity is stored in the color map's alpha channel.
		float4 light = shaderTextures[1].Sample(samplers[0], input.TexCoord);
		float3 diffuseLight = light.rgb;
		float specularLight = light.a;
		
		//Not going to apply specular here, it'll be applied in the final composition stage.
		return lerp(float4(ao*(baseColor * (diffuseLight + specularLight)), 1.0f),  FogColor, fogFactor); // + (fogFactor * FogColor)
}

/*
Linear fog adds a linear amount of fog based on the distance you are viewing the object from:

	Linear Fog = (FogEnd - ViewpointDistance) / (FogEnd - FogStart)
Exponential fog adds exponentially more fog the further away an object is inside the fog:

	Exponential Fog = 1.0 / 2.71828 power (ViewpointDistance * FogDensity)
Exponential 2 fog adds even more exponential fog than the previous equation giving a very thick fog appearance:

	Exponential Fog 2 = 1.0 / 2.71828 power ((ViewpointDistance * FogDensity) * (ViewpointDistance * FogDensity))
All three equations produce a fog factor. To apply that fog factor to the model's texture and produce a final pixel color value we use the following equation:

	Fog Color = FogFactor * TextureColor + (1.0 - FogFactor) * FogColor
*/