/////////////
// GLOBALS //
/////////////
Texture2DArray shaderTexture;
SamplerState linearSampler;

//////////////
// TYPEDEFS //
//////////////
struct PixelInputType
{
	float4 Position : SV_POSITION;
	float3 Normal : NORMAL;
	float4 TexCoord : TEXCOORD0;
};

struct PixelShaderOutput
{
	half4 Color : SV_TARGET0; //R8G8B8A8
	half4 Normal : SV_TARGET1; //R8G8B8A8
	float Depth : SV_TARGET2; //R32
};

////////////////////////////////////////////////////////////////////////////////
// Functions
////////////////////////////////////////////////////////////////////////////////
float EncodeMaterialID(float id)
{
	return (id / 255.0f);
}

//http://aras-p.info/texts/CompactNormalStorage.html#method04spheremap
//Normal Encoding Function
half3 Encode(half3 n)
{
	half p = sqrt(n.z*8.0f+8.0f);
	return half3(n.xy/p + 0.5f, 0.0f);

	return n;
}

////////////////////////////////////////////////////////////////////////////////
// Pixel Shader
////////////////////////////////////////////////////////////////////////////////
PixelShaderOutput VegetationQuadPixelShader(PixelInputType input)
{
	PixelShaderOutput output;

	float fadeFactor = saturate(((input.TexCoord.w*150.0f) - 148.0f) / (150.0f - 148.0f));

	//No branching cuz texture array. Yay. To clarify -- our texCoord.z channel contains texture ID, which we extract from each instance of vegetation.
<<<<<<< HEAD
	output.Color = lerp(float4(0.5f, 0.5f, 0.5f, 0.0f), shaderTexture.Sample(linearSampler, input.TexCoord.xyz), 1.0f-fadeFactor);
=======
	output.Color = lerp(float4(0.3f, 0.3f, 0.3f, 0.3f), shaderTexture.Sample(linearSampler, input.TexCoord.xyz), 1.0f-fadeFactor);
>>>>>>> a0d97d6b7ec8f881286898508a825e12fe8dc502

	if(output.Color.w <= 0.7f) //Alpha testing and tiny optimization for the break-early cases, I guess.
	{
		discard;
	}

	output.Depth = (input.TexCoord.w); //We stored postProj.z/w in TexCoord.z to save one register slot of space.

	output.Normal.xyz = Encode(normalize(input.Normal)); //TODO: Change.

	//This is our material ID. Our normal map is R8G8B8A8, so our z and w channels each have 8 bits == 255 possible values.
	output.Normal.z = EncodeMaterialID(4.0f);
	output.Normal.w = EncodeMaterialID(4.0f);

	return output;
}