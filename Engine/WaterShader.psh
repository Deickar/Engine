Texture2D normalTexture : register( ps_5_0, t0 );
Texture2D waterTexture : register( ps_5_0, t1 );
SamplerState linearSampler;

cbuffer PixelMatrixBuffer
{
	float4x4 World;
};

struct PSInput
{
	float4 Position : SV_POSITION;
	float4 TexCoord	: TEXCOORD0; //xy channels are real texture coordinates. .z channel is height offset for coloring etc. .w channel is viewspace depth.
};

struct PSOutput
{
	float4 Color : SV_TARGET0; //R8G8B8A8
	float4 Normal : SV_TARGET1; //R8G8B8A8
	float Depth : SV_TARGET2; //R32
};

//http://aras-p.info/texts/CompactNormalStorage.html#method04spheremap
//Normal Encoding Function
float2 Encode(float3 n)
{
	float p = sqrt(n.z*8.0f+8.0f);
	return float2(n.xy/p + 0.5f);
}

//Since it's an 8bit UNORM channel, it means every value will end up in the 0..1 spectrum, so we have to do some trickery to save it and unload it properly.
float EncodeMaterialID(float id)
{
	return (id / 255.0f);
}

static const float3 UpNormal = float3(0.0f, 1.0f, 0.0f);

PSOutput WaterShaderPS(PSInput input)
{
	PSOutput output;

	//Offset by 0.2f and scale the rest by 0.8f to make the avg. color brighter while maintaining the same max value.
	float waterColorOffset = 0.2f + (input.TexCoord.z*0.8f);

	//Depth has been stored in normal .w channel.
	output.Depth = (input.TexCoord.w / 400.0f);

	float4 PreCalcNormal = normalize(float4(UpNormal + normalTexture.SampleLevel(linearSampler, input.TexCoord.xy, 0).xyz, 1.0f));

	float3 normal =  mul(PreCalcNormal, World).xyz;

	output.Normal.xy = Encode(normal);
	output.Normal.zw = EncodeMaterialID(6.0f); //Both channels are reserved for material ID. Assign the water material.

	//So my mode of thinking here is that the higher the water is, the brighter the colors I want. 
	//I feel this reflects reality because more light escapes the thinner the water is, if you know what I mean.
	output.Color = saturate(float4(0.0f, 0.35f, 0.5f, 0.85f) * float4(waterColorOffset, waterColorOffset, waterColorOffset, 1.0f));

	return output;
}