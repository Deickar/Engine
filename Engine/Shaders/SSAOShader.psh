cbuffer PixelShaderBuffer
{
	float4x4 View;
	float4x4 Projection;
	float thFOV;
	float aspectRatio;
	float2 PADDING;
	float4 samplingRays[14]; //Sampling kernel
}

struct VertexShaderOutput
{
	float4 Position : SV_POSITION;
	float2 TexCoord : TEXCOORD0;
	float3 ViewRay	: TEXCOORD1;
};

SamplerState linearSampler : register(s0);
Texture2D shaderTextures[3] : register(ps_5_0, t0); //0 == depth, 1 == normal, 2 == random vectors

static const int kernelSize = 14;

static const float samplingRadius = 1.5f;
static const float intensity = 4.0f;

static const float2 screenSize = float2(1024.0f, 768.0f);
static const float2 randomTextureSize = float2(128.0f, 128.0f);

static const float    gOcclusionFadeStart = 0.2f;
static const float    gOcclusionFadeEnd   = 2.0f;
static const float    gSurfaceEpsilon     = 0.25f;

//Decoding of GBuffer Normals
half3 DecodeNormal(half2 enc)
{
	half2 fenc = enc*4-2;
	half f = dot(fenc,fenc);
	half g = sqrt(1-f*0.25);
	return half3(fenc*g, 1-f*0.5);
}

float3 ReconstructViewPositionFromDepth(float3 viewRay, float depth)
{
	return viewRay * depth;
}

float3 GetRandomVector(float2 uv)
{
	return 2.0f * shaderTextures[2].Sample(linearSampler, (((screenSize.xy * uv.xy) / randomTextureSize.xy))).xyz - 1.0f;//normalize(mul(, (float3x3)View)); //shaderTextures[2].SampleLevel(linearSampler, (((screenSize.xy * uv.xy) / randomTextureSize.xy)), 0.0f) * 2.0f - 1.0f; //
}

// Determines how much the sample point q occludes the point p as a function
// of distZ.
float OcclusionFunction(float distZ)
{
	// If depth(q) is "behind" depth(p), then q cannot occlude p.  Moreover, if 
	// depth(q) and depth(p) are sufficiently close, then we also assume q cannot
	// occlude p because q needs to be in front of p by Epsilon to occlude p.
	//
	// We use the following function to determine the occlusion.  
	// 
	//
	//       1.0     -------------\
	//               |           |  \
	//               |           |    \
	//               |           |      \ 
	//               |           |        \
	//               |           |          \
	//               |           |            \
	//  ------|------|-----------|-------------|---------|--> zv
	//        0     Eps          z0            z1        

	float occlusion = 0.0f;
	if(distZ >= gSurfaceEpsilon)
	{
		float fadeLength = gOcclusionFadeEnd - gOcclusionFadeStart;

		// Linearly decrease occlusion from 1 to 0 as distZ goes 
		// from gOcclusionFadeStart to gOcclusionFadeEnd.    
		occlusion = saturate((gOcclusionFadeEnd-distZ)/fadeLength);
	}

	return occlusion;    
}

float SSAOPixelShader(VertexShaderOutput input) : SV_Target0
{
	float depth = shaderTextures[0].Sample(linearSampler, input.TexCoord);

	float3 normal = normalize(DecodeNormal(shaderTextures[1].Sample(linearSampler, input.TexCoord).xy));

	float3 viewPosition = (input.ViewRay * depth); //input.ViewRay // float3((input.TexCoord.x*2.0f-1.0f) * thFOV * aspectRatio, (input.TexCoord.y*2.0f-1.0f) * thFOV, 1.0)
	float3 randomVector = GetRandomVector(input.TexCoord.xy);

	float occlusion = 0.0f;

	for(int i = 0; i < kernelSize; i++)
	{
		float3 offset = 2.0f * reflect(samplingRays[i].xyz, randomVector) - 1.0f;
		normal.x *= -1.0f;
		offset.x *= -1.0f;

		//normal.z *= -1.0f;
		//offset.z *= -1.0f;

		//Doing a manual sign because sign might return 0 if the dot == 0
		float flip = (dot(normal, offset) >= 0.0f) ? 1.0f : -1.0f;
		float3 q = (viewPosition + (samplingRadius * (flip * offset)));

		float4 projectedCoords = mul(float4(q, 1.0f), Projection);
		projectedCoords /= projectedCoords.w;


		float sampleDepth = 1.0f - shaderTextures[0].Sample(linearSampler, projectedCoords.xy);
		float3 ray = (q.xyz * sampleDepth);

		float distance = abs(viewPosition.z - ray.z);
		float dp = dot(normal, normalize(ray - viewPosition));

		occlusion += flip * (dp * OcclusionFunction(distance));
	}

	occlusion = 1.0f - (occlusion / kernelSize);

	return saturate(pow(occlusion, intensity));
}

//THIS WORKS! Backup...

/*
cbuffer PixelShaderBuffer
{
	float4x4 View;
	float4x4 Projection;
	float thFOV;
	float aspectRatio;
	float2 PADDING;
	float4 samplingRays[14]; //Sampling kernel
}

struct VertexShaderOutput
{
	float4 Position : SV_POSITION;
	float2 TexCoord : TEXCOORD0;
	float3 ViewRay	: TEXCOORD1;
};

SamplerState linearSampler : register(s0);
Texture2D shaderTextures[3] : register(ps_5_0, t0); //0 == depth, 1 == normal, 2 == random vectors

static const int kernelSize = 14;

static const float samplingRadius = 1.5f;
static const float intensity = 4.0f;

static const float2 screenSize = float2(1024.0f, 768.0f);
static const float2 randomTextureSize = float2(128.0f, 128.0f);

static const float    gOcclusionFadeStart = 0.2f;
static const float    gOcclusionFadeEnd   = 2.0f;
static const float    gSurfaceEpsilon     = 0.25f;

//Decoding of GBuffer Normals
half3 DecodeNormal(half2 enc)
{
	half2 fenc = enc*4-2;
	half f = dot(fenc,fenc);
	half g = sqrt(1-f*0.25);
	return half3(fenc*g, 1-f*0.5);
}

float3 ReconstructViewPositionFromDepth(float3 viewRay, float depth)
{
	return viewRay * depth;
}

float3 GetRandomVector(float2 uv)
{
	return 2.0f * shaderTextures[2].Sample(linearSampler, (((screenSize.xy * uv.xy) / randomTextureSize.xy))).xyz - 1.0f;//normalize(mul(, (float3x3)View)); //shaderTextures[2].SampleLevel(linearSampler, (((screenSize.xy * uv.xy) / randomTextureSize.xy)), 0.0f) * 2.0f - 1.0f; //
}

// Determines how much the sample point q occludes the point p as a function
// of distZ.
float OcclusionFunction(float distZ)
{
	// If depth(q) is "behind" depth(p), then q cannot occlude p.  Moreover, if 
	// depth(q) and depth(p) are sufficiently close, then we also assume q cannot
	// occlude p because q needs to be in front of p by Epsilon to occlude p.
	//
	// We use the following function to determine the occlusion.  
	// 
	//
	//       1.0     -------------\
	//               |           |  \
	//               |           |    \
	//               |           |      \ 
	//               |           |        \
	//               |           |          \
	//               |           |            \
	//  ------|------|-----------|-------------|---------|--> zv
	//        0     Eps          z0            z1        

	float occlusion = 0.0f;
	if(distZ >= gSurfaceEpsilon)
	{
		float fadeLength = gOcclusionFadeEnd - gOcclusionFadeStart;

		// Linearly decrease occlusion from 1 to 0 as distZ goes 
		// from gOcclusionFadeStart to gOcclusionFadeEnd.    
		occlusion = saturate((gOcclusionFadeEnd-distZ)/fadeLength);
	}

	return occlusion;    
}

float SSAOPixelShader(VertexShaderOutput input) : SV_Target0
{
	float depth = shaderTextures[0].Sample(linearSampler, input.TexCoord);

	float3 normal = normalize(DecodeNormal(shaderTextures[1].Sample(linearSampler, input.TexCoord).xy));

	float3 viewPosition = (input.ViewRay * depth); //input.ViewRay // float3((input.TexCoord.x*2.0f-1.0f) * thFOV * aspectRatio, (input.TexCoord.y*2.0f-1.0f) * thFOV, 1.0)
	float3 randomVector = GetRandomVector(input.TexCoord.xy);

	float occlusion = 0.0f;

	for(int i = 0; i < kernelSize; i++)
	{
		float3 offset = 2.0f * reflect(samplingRays[i].xyz, randomVector) - 1.0f;
		normal.x *= -1.0f;
		offset.x *= -1.0f;

		//normal.z *= -1.0f;
		//offset.z *= -1.0f;

		//Doing a manual sign because sign might return 0 if the dot == 0
		float flip = (dot(normal, offset) >= 0.0f) ? 1.0f : -1.0f;
		float3 q = (viewPosition + (samplingRadius * (flip * offset)));

		float4 projectedCoords = mul(float4(q, 1.0f), Projection);
		projectedCoords /= projectedCoords.w;


		float sampleDepth = 1.0f - shaderTextures[0].Sample(linearSampler, projectedCoords.xy);
		float3 ray = (q.xyz * sampleDepth);

		float distance = abs(viewPosition.z - ray.z);
		float dp = dot(normal, normalize(ray - viewPosition));

		occlusion += flip * (dp * OcclusionFunction(distance));
	}

	occlusion = 1.0f - (occlusion / kernelSize);

	return saturate(pow(occlusion, intensity));
}

*/