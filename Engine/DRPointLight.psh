cbuffer LightBufferType
{
	float4 LightPosition;
	float3 LightColor;
	float LightRadius;
	float LightPower;
	float3 CameraPosition;
}

cbuffer PixelMatrixBufferType
{
	float4x4 InvViewProjection;
}

struct VertexShaderOutput
{
	float4 Position : SV_Position;
	float4 ScreenPosition : TEXCOORD0;
};

//Decoding of GBuffer Normals
float3 Decode(float3 enc)
{
	return (2.0f * enc.xyz - 1.0f);
}

Texture2D textures[3]; //Color, Normal, depth. In that order
SamplerState pointSampler;

half4 LightPixelShader(VertexShaderOutput input) : SV_TARGET0
{
	input.ScreenPosition /= input.ScreenPosition.w; //Get screen position

	float2 texCoord = 0.5f * (float2(input.ScreenPosition.x, -input.ScreenPosition.y) + 1.0f);

	//get normal data from the normalMap
	float4 normalData = textures[1].Sample(pointSampler, texCoord);
	float depth = textures[2].Sample(pointSampler, texCoord);
	float3 normal = normalize(normalData.xyz);
	
	//Create a clip space position (I think?)
	float4 position;
	position.xy = input.ScreenPosition.xy;
	position.z = depth; //With depth from camera
	position.w = 1.0f;

	position = mul(position, InvViewProjection); //And revert it back to world position
	position /= position.w;

	float4 adjustedLightPos = LightPosition;
	adjustedLightPos.y -= 0.5f; //Need to adjust light position so that origin is at the center of the sphere...

	//surface-to-light vector
	float3 lightVector =  normalize(position-adjustedLightPos);

	float d = distance(position, adjustedLightPos);
	float attenuation = (1.0f / ((d*d)+0.6f)); //Slight offset to dampen the light

	//compute diffuse light
	float NdL = max(dot(normal, lightVector), 0);

	float3 diffuseLight = (NdL * LightColor.rgb);

	//reflection vector
	float3 reflectionVector = normalize(reflect(-lightVector, normal));

	//camera-to-surface vector
	float3 directionToCamera = normalize(CameraPosition-position);

	//compute specular light
	float specularLight =  pow( saturate(dot(reflectionVector, directionToCamera)), LightPower); //it's 128 because idk.

	return attenuation * half4(diffuseLight, specularLight);
}

/*
		//surface-to-light vector
		float3 lightVector = (-LightDirection);
		//Calculate diffuse intensity, the usual
		float NdL = (max(0, dot(normal, lightVector)));
		//reflection vector
		float3 reflectionVector = normalize(-reflect(lightVector, normal));
		//camera-to-surface vector
		float3 directionToCamera = normalize(position-CameraPosition);
		//compute diffuse light
		finalDiffuseProduct.xyzw += Kd * NdL;
		//compute specular light 
		finalSpecularProduct += Ks * pow( saturate(dot(directionToCamera, reflectionVector)), a);
*/


/*
vec3 DirectIllumination(vec3 P, vec3 N, vec3 lightCentre, float lightRadius, vec3 lightColour, float cutoff)
{

	float r = lightRadius;
	vec3 L = lightCentre - P;
	float distance = length(L);
	float d = max(distance - r, 0);
	L /= distance;
	
	// calculate basic attenuation
	float denom = d/r + 1;
	float attenuation = 1 / (denom*denom);
	
	// scale and bias attenuation such that:
	//   attenuation == 0 at extent of max influence
	//   attenuation == 1 when d == 0
	attenuation = (attenuation - cutoff) / (1 - cutoff);
	attenuation = max(attenuation, 0);
	
	float dot = max(dot(L, N), 0);
	return lightColour * dot * attenuation;
}

*/