cbuffer PositionalBuffer //Whatever, idk what else to name it
{
	float3 LightDirection;
	float3 LightPosition;
	float3 CameraPosition;
	float3 Padding;
}
;
cbuffer PixelMatrixBuffer
{
	float4x4 LightViewProjection;
	float4x4 InverseView;
	float4x4 InverseViewProjection;
}
;
cbuffer LightBuffer
{
	float4 DiffuseColor;
	float4 AmbientColor;
	float Ka;
	//Ambient light coefficient
	float Kd;
	//Diffuse light coefficient
	float Ks;
	//Specular light coefficient
	float a;
	//Alpha coefficient
};

//0 == linear, 1 == point
SamplerState samplers[2];

// 0 = normal, 1 = standard depth, 2 = shadowmap depth.
Texture2D shaderTextures[3];


struct VertexShaderOutput
{
	float4 Position : SV_POSITION;
	float2 TexCoord : TEXCOORD0;
	float4 ViewPosition : TEXCOORD1;
	float4 ScreenPosition : TEXCOORD2;
}
;
//Decoding of GBuffer Normals
float3 decode(float3 enc)
{
	return (2.0f * enc.xyz- 1.0f);
}


half4 LightPixelShader(VertexShaderOutput input) : SV_Target
{
	//compute ambient light
	half4 finalAmbienceProduct = half4(0.0f, 0.0f, 0.0f, 0.0f);

	float depth = shaderTextures[1].Sample(samplers[1], input.TexCoord);
	
	if(0 >= depth) //Skip as early as possible if this pixel isn't supposed to be lit.
	{
		return finalAmbienceProduct; //0, 0, 0, 0
	}

	finalAmbienceProduct += Ka * AmbientColor;
	float4 encodedNormal = shaderTextures[0].Sample(samplers[0], input.TexCoord);
	float3 normal = normalize(decode(encodedNormal.xyz));
	
	float4 position;
	position = float4(input.Position.xyz * depth, 1.0f);

	//position = mul(position, InverseViewProjection);

	//http://www.gamedev.net/topic/635060-csm-help-problem-with-cascadesshadowmap-solved/
	//http://www.xbdev.net/misc_demos/demos/shadow_maps/paper.pdf

	float4x4 invertedLVP = mul(InverseViewProjection, LightViewProjection);

	float4 lightScreenPos = mul(position, invertedLVP);
	//lightScreenPos = mul(lightScreenPos, InverseView);

	lightScreenPos.xyz /= lightScreenPos.w;

	float realDistanceToLight = lightScreenPos.z;

	float2 sampleLightScreen;
	sampleLightScreen.x = (lightScreenPos.x * 0.5f + 0.5f);
	sampleLightScreen.y = (-lightScreenPos.y * 0.5f + 0.5f);

	float shadowMultiplier = 1.0f;
	
	if(!(sampleLightScreen.x > 1 || sampleLightScreen.x < 0 || sampleLightScreen.y > 1 || sampleLightScreen.y < 0))
	{
		float distanceStoredInDepthMap = shaderTextures[2].Sample(samplers[1], sampleLightScreen);
		
		if (realDistanceToLight < 1 && realDistanceToLight - 0.0002f > distanceStoredInDepthMap)
		{
			shadowMultiplier = 0.2f;
		}

	}
	
	//surface-to-light vector
	float3 lightVector = -LightDirection;

	//Sigh, idk
	float NdL = max(0, dot(normal, lightVector));

	//reflection vector
	float3 reflectionVector = normalize(-reflect(lightVector, normal));

	//camera-to-surface vector
	float3 directionToCamera = normalize(position-CameraPosition);

	//compute diffuse light
	half4 finalDiffuseProduct = half4(0.0f, 0.0f, 0.0f, 0.0f);
	finalDiffuseProduct.xyzw += Kd * NdL;

	//compute specular light 
	float finalSpecularProduct = 0.0f;
	finalSpecularProduct += Ks * pow( saturate(dot(directionToCamera, reflectionVector)), a);

	//Storing specular in alpha channel. Applying shadow multiplier to both diffuse product and specular, but not ambient, to make sure it's not just black.
		return half4(finalAmbienceProduct.rgb + shadowMultiplier * (DiffuseColor.rgb*finalDiffuseProduct.rgb), shadowMultiplier * finalSpecularProduct);
}



/*


float4 ps_lighting(VS_OUTPUT IN) : SV_Target
{
	if (renderingSkel || renderingRBody)
	{
		return float4(1, 1, 1, 1);
	}
	else
	{
		//shadow mapping stuff
		IN.LightPosition.xyz /= IN.LightPosition.w;
		
		float4 ambient = ambientBright * materialAmbient;

		if( IN.LightPosition.x < -1.0f || IN.LightPosition.x > 1.0f || IN.LightPosition.y < -1.0f || IN.LightPosition.y > 1.0f || IN.LightPosition.z < 0.0f  || IN.LightPosition.z > 1.0f ) 
			return ambient;

		IN.LightPosition.x = IN.LightPosition.x/2 + 0.5;
		IN.LightPosition.y = IN.LightPosition.y/-2 + 0.5;

		float shadowMapDepth = shadowMap.Sample(ShadowSampler, IN.LightPosition.xy).r;

		if (shadowMapDepth < IN.LightPosition.z) return ambient;

		float3 V = normalize(IN.eye - IN.position);
		float3 R = reflect(lightDir, IN.normal);
		
		float4 diffuse = diffuseBright * (materialDiffuse * saturate(dot(lightDir, IN.normal)));
		float4 specular = specularBright * pow(saturate(dot(R, V)), normalize(shine));
		float4 finalColor = ambient + diffuse;
		if (shine > 0)
		{
			finalColor = saturate(finalColor + specular);
		}

		

		float4 color = texDiffuse.Sample(DiffuseSampler, IN.tex0);
		float4 sphCol = sphTexture.Sample(SphereSampler, IN.spTex);
		if (useTexture)
		{
			finalColor *= color;
		}
		if (useSphere)
		{
			if (isSphereAdd)
			{
				finalColor += sphCol;
			}
			else
			{
				finalColor *= sphCol;
			}
		}
		float4 o = (finalColor * extraBright) * fadeCoef;
		if (useTexture)
		{
			o.a = color.a * materialDiffuse.a;
		}
		else
		{
			o.a = materialDiffuse.a;
		}
		return o;
	}
}


*/